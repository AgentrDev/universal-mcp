import os
import re
from pathlib import Path

import litellm
import typer
from rich.console import Console
from rich.panel import Panel
from rich.status import Status

from universal_mcp.utils.installation import (
    get_supported_apps,
    install_app,
)

# Setup rich console and logging
console = Console()

app = typer.Typer()


@app.command()
def generate(
    schema_path: Path = typer.Option(..., "--schema", "-s"),
    output_path: Path = typer.Option(
        None,
        "--output",
        "-o",
        help="Output file path - should match the API name (e.g., 'twitter.py' for Twitter API)",
    ),
    class_name: str = typer.Option(
        None,
        "--class-name",
        "-c",
        help="Class name to use for the API client",
    ),
):
    """Generates Python client code from an OpenAPI (Swagger) schema.

    This command automates the creation of an API client class, including
    methods for each API operation defined in the schema. The generated
    code is designed to integrate with the Universal MCP application framework.

    It's recommended that the output filename (if specified via -o) matches
    the API's service name (e.g., 'twitter.py' for a Twitter API client)
    as this convention is used for organizing applications within U-MCP.
    If no output path is provided, the generated code will be printed to the console.
    """
    # Import here to avoid circular imports
    from universal_mcp.utils.openapi.api_generator import generate_api_from_schema

    if not schema_path.exists():
        console.print(f"[red]Error: Schema file {schema_path} does not exist[/red]")
        raise typer.Exit(1)

    try:
        app_file_data = generate_api_from_schema(
            schema_path=schema_path,
            output_path=output_path,
            class_name=class_name,
        )
        if isinstance(app_file_data, dict) and "code" in app_file_data:
            console.print("[yellow]No output path specified, printing generated code to console:[/yellow]")
            console.print(app_file_data["code"])
        elif isinstance(app_file_data, Path):
            console.print("[green]API client successfully generated and installed.[/green]")
            console.print(f"[blue]Application file: {app_file_data}[/blue]")
        else:
            # Handle the error case from api_generator if validation fails
            if isinstance(app_file_data, dict) and "error" in app_file_data:
                console.print(f"[red]{app_file_data['error']}[/red]")
                raise typer.Exit(1)
            else:
                console.print("[red]Unexpected return value from API generator.[/red]")
                raise typer.Exit(1)

    except Exception as e:
        console.print(f"[red]Error generating API client: {e}[/red]")
        raise typer.Exit(1) from e


@app.command()
def readme(
    file_path: Path = typer.Argument(..., help="Path to the Python API client file (e.g., app.py) to process"),
):
    """Generates a basic README.md file for a Universal MCP application.

    This command inspects a given Python application file (typically one
    generated by the `generate` command or manually created) and creates
    a README.md file. The README will include information about the
    application's tools, derived from their docstrings.
    """
    from universal_mcp.utils.openapi.readme import generate_readme

    readme_file = generate_readme(file_path)
    console.print(f"[green]README.md file generated at: {readme_file}[/green]")


@app.command()
def docgen(
    file_path: Path = typer.Argument(..., help="Path to the Python file to process"),
    model: str = typer.Option(
        "perplexity/sonar",
        "--model",
        "-m",
        help="Model to use for generating docstrings",
    ),
):
    """Generates Google-style docstrings for functions and methods in a Python file.

    This command leverages a Large Language Model (LLM) via LiteLLM
    to analyze the code in the specified Python file and generate
    descriptive, Google-style docstrings for its functions and methods.
    It's particularly useful for documenting generated or existing API clients.
    """
    from universal_mcp.utils.openapi.docgen import process_file

    if not file_path.exists():
        console.print(f"[red]Error: File not found: {file_path}[/red]")
        raise typer.Exit(1)

    try:
        processed = process_file(str(file_path), model)
        console.print(f"[green]Successfully processed {processed} functions[/green]")
    except Exception as e:
        console.print(f"[red]Error: {e}[/red]")
        raise typer.Exit(1) from e


@app.command()
def run(
    config_path: Path | None = typer.Option(None, "--config", "-c", help="Path to the JSON server configuration file."),
):
    """Runs the Universal MCP server.

    This command initializes and starts the MCP server based on the settings
    defined in a JSON configuration file. The configuration specifies the
    server type (e.g., local, agentr), transport mechanism (e.g., sse, http),
    port, applications to load, and credential store settings.

    If no configuration path is provided via the --config/-c option,
    it will attempt to run with a default `ServerConfig()` instance.
    """
    from universal_mcp.config import ServerConfig
    from universal_mcp.logger import setup_logger
    from universal_mcp.servers import server_from_config

    config = ServerConfig.model_validate_json(config_path.read_text()) if config_path else ServerConfig()
    setup_logger(level=config.log_level)
    server = server_from_config(config)
    server.run(transport=config.transport)


@app.command()
def install(app_name: str = typer.Argument(..., help="Name of the desktop application to configure (e.g., 'claude', 'cursor')")):
    """Configures supported desktop applications to use Universal MCP.

    This command sets up the necessary configurations for specific desktop
    applications (like Claude or Cursor) to enable them to communicate
    with a Universal MCP server, allowing them to leverage MCP tools.

    An AgentR API key is required for this process, as it facilitates
    the secure connection and configuration with the AgentR platform,
    which may manage aspects of the U-MCP integration for these desktop apps.
    """
    # List of supported apps
    supported_apps = get_supported_apps()

    if app_name not in supported_apps:
        console.print("[yellow]Available apps:[/yellow]")
        for app in supported_apps:
            console.print(f"  - {app}")
        console.print(f"\n[red]App '{app_name}' not supported[/red]")
        raise typer.Exit(1)

    # Print instructions before asking for API key
    console.print(
        Panel(
            "API key is required. Visit [link]https://agentr.dev[/link] to create an API key.",
            title="Instruction",
            border_style="blue",
            padding=(1, 2),
        )
    )

    # Prompt for API key
    api_key = typer.prompt(
        "Enter your AgentR API key",
        hide_input=False,
        show_default=False,
        type=str,
    )
    try:
        install_app(app_name, api_key)
    except Exception as e:
        console.print(f"[red]Error installing app: {e}[/red]")
        raise typer.Exit(1) from e


@app.command()
def init(
    output_dir: Path | None = typer.Option(
        None,
        "--output-dir",
        "-o",
        help="Output directory for the project (must exist)",
    ),
    app_name: str | None = typer.Option(
        None,
        "--app-name",
        "-a",
        help="App name (letters, numbers, hyphens, underscores only)",
    ),
    integration_type: str | None = typer.Option(
        None,
        "--integration-type",
        "-i",
        help="Integration type (api_key, oauth, agentr, none)",
        case_sensitive=False,
        show_choices=True,
    ),
):
    """Initializes a new Universal MCP application package from a template.

    This command uses a Cookiecutter template to scaffold a new Python project
    structured as a Universal MCP application. It sets up the basic file
    layout, boilerplate code, and configuration files needed to start
    developing a new U-MCP compatible application.

    You will be prompted for the application name, output directory,
    and integration type (e.g., api_key, oauth, agentr, none) if not
    provided as options.
    """
    from cookiecutter.main import cookiecutter

    NAME_PATTERN = r"^[a-zA-Z0-9_-]+$"

    def validate_pattern(value: str, field_name: str) -> None:
        if not re.match(NAME_PATTERN, value):
            console.print(
                f"[red]❌ Invalid {field_name}; only letters, numbers, hyphens, and underscores allowed.[/red]"
            )
            raise typer.Exit(code=1)

    # App name
    if not app_name:
        app_name = typer.prompt(
            "Enter the app name",
            default="app_name",
            prompt_suffix=" (e.g., reddit, youtube): ",
        ).strip()
    validate_pattern(app_name, "app name")
    app_name = app_name.lower()
    if not output_dir:
        path_str = typer.prompt(
            "Enter the output directory for the project",
            default=str(Path.cwd()),
            prompt_suffix=": ",
        ).strip()
        output_dir = Path(path_str)

    if not output_dir.exists():
        try:
            output_dir.mkdir(parents=True, exist_ok=True)
            console.print(f"[green]✅ Created output directory at '{output_dir}'[/green]")
        except Exception as e:
            console.print(f"[red]❌ Failed to create output directory '{output_dir}': {e}[/red]")
            raise typer.Exit(code=1) from e
    elif not output_dir.is_dir():
        console.print(f"[red]❌ Output path '{output_dir}' exists but is not a directory.[/red]")
        raise typer.Exit(code=1)

    # Integration type
    if not integration_type:
        integration_type = typer.prompt(
            "Choose the integration type",
            default="agentr",
            prompt_suffix=" (api_key, oauth, agentr, none): ",
        ).lower()
    if integration_type not in ("api_key", "oauth", "agentr", "none"):
        console.print("[red]❌ Integration type must be one of: api_key, oauth, agentr, none[/red]")
        raise typer.Exit(code=1)

    console.print("[blue]🚀 Generating project using cookiecutter...[/blue]")
    try:
        cookiecutter(
            "https://github.com/AgentrDev/universal-mcp-app-template.git",
            output_dir=str(output_dir),
            no_input=True,
            extra_context={
                "app_name": app_name,
                "integration_type": integration_type,
            },
        )
    except Exception as exc:
        console.print(f"❌ Project generation failed: {exc}")
        raise typer.Exit(code=1) from exc

    project_dir = output_dir / f"{app_name}"
    console.print(f"✅ Project created at {project_dir}")


@app.command()
def preprocess(
    schema_path: Path = typer.Option(None, "--schema", "-s", help="Path to the input OpenAPI schema file (JSON or YAML)."),
    output_path: Path = typer.Option(None, "--output", "-o", help="Path to save the processed (enhanced) OpenAPI schema file."),
):
    """Enhances an OpenAPI schema's descriptions using an LLM.

    This command takes an existing OpenAPI schema and uses a Large Language
    Model (LLM) to automatically generate or improve the descriptions for
    API paths, operations, parameters, and schemas. This is particularly
    helpful for schemas that are auto-generated or lack comprehensive
    human-written documentation, making the schema more understandable and
    usable for client generation or manual review.
    """
    from universal_mcp.utils.openapi.preprocessor import run_preprocessing
    run_preprocessing(schema_path, output_path)


@app.command()
def split_api(
    input_app_file: Path = typer.Argument(..., help="Path to the single, generated Python API client file (e.g., app.py) to be split."),
    output_dir: Path = typer.Option(..., "--output-dir", "-o", help="Directory where the split Python files will be saved."),
    package_name: str = typer.Option(None, "--package-name", "-p", help="Optional base package name for generating absolute imports in the split files (e.g., 'my_mcp_app.hubspot')."),
):
    """Splits a large, single-file generated API client into multiple Python modules.

    When an OpenAPI schema results in a very large API client class, this command
    can divide it into smaller, more manageable files. The splitting is typically
    done based on logical groupings within the API, often derived from tags or
    common URL path segments defined in the OpenAPI schema. This improves code
    organization and maintainability for complex APIs.

    The `package_name` option helps in structuring the import statements correctly
    if the split files are part of a larger Python package.
    """
    from universal_mcp.utils.openapi.api_splitter import split_generated_app_file

    if not input_app_file.exists() or not input_app_file.is_file():
        console.print(f"[red]Error: Input file {input_app_file} does not exist or is not a file.[/red]")
        raise typer.Exit(1)

    if not output_dir.exists():
        output_dir.mkdir(parents=True, exist_ok=True)
        console.print(f"[green]Created output directory: {output_dir}[/green]")
    elif not output_dir.is_dir():
        console.print(f"[red]Error: Output path {output_dir} is not a directory.[/red]")
        raise typer.Exit(1)

    try:
        split_generated_app_file(input_app_file, output_dir, package_name)
        console.print(f"[green]Successfully split {input_app_file} into {output_dir}[/green]")
    except Exception as e:
        console.print(f"[red]Error splitting API client: {e}[/red]")

        raise typer.Exit(1) from e


def _model_callback(model: str) -> str:
    """
    Validates the model and checks if the required API key is set.
    This callback is now silent on success.
    """
    api_key_env_var = None
    if "claude" in model:
        api_key_env_var = "ANTHROPIC_API_KEY"
    elif "gpt" in model:
        api_key_env_var = "OPENAI_API_KEY"
    elif "gemini" in model:
        api_key_env_var = "GEMINI_API_KEY"
    elif "perplexity" in model:
        api_key_env_var = "PERPLEXITYAI_API_KEY"

    if api_key_env_var and not os.getenv(api_key_env_var):
        error_message = f"Environment variable '{api_key_env_var}' is not set. Please set it to use the '{model}' model."
        raise typer.BadParameter(error_message)
    elif not api_key_env_var:
        console.print(f"[yellow]Warning: Could not determine the required API key for model '{model}'.[/yellow]")
        console.print("Please ensure the correct environment variable (e.g., OPENAI_API_KEY) is set for LiteLLM to use.")

    return model

@app.command()
def llm_generate(
    output_dir: Path = typer.Option(
        Path.cwd(),
        "--output-dir",
        "-o",
        help="Directory to save 'app.py'. Defaults to the current directory.",
        prompt="Enter the output directory",
        resolve_path=True,
    ),
    model: str = typer.Option(
        "perplexity/sonar",
        "--model",
        "-m",
        help="The LLM model to use for generation (via LiteLLM).",
        prompt="Enter the LLM model to use",
        callback=_model_callback,
    ),
    prompt: str = typer.Option(
        ...,
        "--prompt",
        "-p",
        help="A natural language description of the application and its tools.",
        prompt="Describe the application and its tools",
    ),
):
    """
    Generates an 'app.py' file from a natural language prompt using an LLM.
    ...
    """
    from universal_mcp.utils.prompts import APP_GENERATOR_SYSTEM_PROMPT

    console.print(f"[bold blue]🚀 Starting App Generation using model: '{model}'[/bold blue]")

    try:
        output_dir.mkdir(parents=True, exist_ok=True)
    except Exception as e:
        console.print(f"[red]❌ Failed to create output directory '{output_dir}': {e}[/red]")
        raise typer.Exit(code=1) from e

    output_file_path = output_dir / "app.py"
    console.print(f"[green]Will save generated file to:[/green] [cyan]{output_file_path}[/cyan]")

    messages = [
        {"role": "system", "content": APP_GENERATOR_SYSTEM_PROMPT},
        {"role": "user", "content": prompt},
    ]

    response = None
    with Status("[bold green]Generating app code... (this may take a moment)[/bold green]", console=console):
        try:
            response = litellm.completion(
                model=model,
                messages=messages,
                temperature=0.1,
                timeout=120,
            )
        # ... (rest of the code is unchanged) ...
        except Exception as e:
            console.print(f"\n[bold red]❌ An error occurred during LLM API call: {e}[/bold red]")
            raise typer.Exit(code=1) from e

    if not response or not response.choices:
        console.print("[bold red]❌ Failed to get a valid response from the LLM.[/bold red]")
        raise typer.Exit(code=1)

    generated_content = response.choices[0].message.content

    code_match = re.search(r"```python\n(.*?)\n```", generated_content, re.DOTALL)
    if code_match:
        final_code = code_match.group(1).strip()
    else:
        console.print("[yellow]Warning: LLM response did not contain a markdown code block. Using the raw response.[/yellow]")
        final_code = generated_content.strip()

    if not final_code:
        console.print("[bold red]❌ The LLM returned an empty code block. Aborting.[/bold red]")
        raise typer.Exit(code=1)

    try:
        output_file_path.write_text(final_code, encoding="utf-8")
        console.print("\n[bold green]✅ Success! Application code saved.[/bold green]")
    except Exception as e:
        console.print(f"\n[bold red]❌ Failed to write the generated code to file: {e}[/bold red]")
        raise typer.Exit(code=1) from e
    
    
if __name__ == "__main__":
    app()
